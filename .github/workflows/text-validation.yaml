# Text Validation Workflow
# Checks capitalization of keywords and other text formatting rules in PR files

name: Text Validation

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'documentation/**'
  workflow_dispatch:

jobs:
  text-validation:
    runs-on: ubuntu-latest
    name: Validate Text Formatting
    permissions:
      contents: read
      pull-requests: write  # Required for commenting on PRs
      issues: write         # Required for issue/PR comments
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get changed files
      id: changed-files
      uses: tj-actions/changed-files@v40
      with:
        files: |
          documentation/CAMARA-API-Event-Subscription-and-Notification-Guide.md
          documentation/CAMARA-API-Design-Guide.md

    - name: Setup Python
      if: steps.changed-files.outputs.any_changed == 'true'
      uses: actions/setup-python@v6
      with:
        python-version: '3.x'

    - name: Create validation script
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        cat > validate_text.py << 'EOF'
        #!/usr/bin/env python3
        import os
        import re
        import sys
        import subprocess
        from pathlib import Path

        def get_pr_diff_lines(filepath):
            """Get the line numbers of added/modified lines in the PR for a specific file."""
            try:
                result = subprocess.run([
                    'git', 'diff', 'origin/main...HEAD', '--unified=0', filepath
                ], capture_output=True, text=True, check=True)
                diff_output = result.stdout
                if not diff_output:
                    return set()
                changed_lines = set()
                for line in diff_output.split('\n'):
                    if line.startswith('@@'):
                        match = re.search(r'\+(\d+)(?:,(\d+))?', line)
                        if match:
                            start_line = int(match.group(1))
                            line_count = int(match.group(2)) if match.group(2) else 1
                            for line_num in range(start_line, start_line + line_count):
                                changed_lines.add(line_num)
                return changed_lines
            except subprocess.CalledProcessError:
                print(f"Warning: Could not get diff for {filepath}, checking entire file")
                return None
            except Exception as e:
                print(f"Error getting diff for {filepath}: {e}")
                return None

        REQUIRED_CAPITALIZATIONS = {
            'must': 'MUST',
            'must not': 'MUST NOT',
            'should': 'SHOULD',
            'should not': 'SHOULD NOT',
            'may': 'MAY',
            'required': 'REQUIRED',
            'recommended': 'RECOMMENDED',
            'not recommended': 'NOT RECOMMENDED',
            'optional': 'OPTIONAL',
            'shall': 'SHALL',
            'shall not': 'SHALL NOT'
            # ... add others as needed
        }

        REQUIRED_NAMES = {
            'github': 'GitHub',
            'api': 'API',
            'apis': 'APIs',
            # ... add others as needed
        }
        VALIDATION_RULES = [
            {
                'name': 'No trailing whitespace',
                'pattern': r'[ \t]+$',
                'message': 'line contains trailing whitespace(s)'
            },
            {
                'name': 'No multiple consecutive spaces',
                'pattern': r'[^\s]  +[^\s]',
                'message': 'multiple consecutive spaces found (should be a single space?)'
            },
            # ... add others as needed
        ]

        def is_in_code_context(text, position):
            before_text = text[:position]
            backtick_blocks = before_text.count('```')
            if backtick_blocks % 2 == 1:
                return True
            lines_before = before_text.split('\n')
            current_line = lines_before[-1] if lines_before else ''
            if re.match(r'^\s{4,}', current_line):
                return True
            current_line_start = before_text.rfind('\n') + 1
            line_to_position = text[current_line_start:position]
            backticks_in_line = line_to_position.count('`')
            if backticks_in_line % 2 == 1:
                return True
            return False

        def check_capitalization(lines, filename, changed_lines):
            issues = []
            text = '\n'.join(lines)
            
            # Sort by length descending: [('must not', 'MUST NOT'), ('must', 'MUST'), ...]
            combined_dict = {**REQUIRED_CAPITALIZATIONS, **REQUIRED_NAMES}
            patterns = sorted(combined_dict.items(), key=lambda kv: -len(kv[0]))
            matched_spans = []
            
            for incorrect, correct in patterns:
                pattern = r'\b' + re.escape(incorrect) + r'\b'
                for match in re.finditer(pattern, text, re.IGNORECASE):
                    matched_text = match.group()
                    start, end = match.start(), match.end()
                    
                    # Check for overlapping spans
                    if any((start < m_end and end > m_start) for m_start, m_end in matched_spans):
                        continue  # Already matched by a longer phrase
                    
                    if matched_text == correct:
                        continue
                    line_num = text[:match.start()].count('\n') + 1
                    if line_num not in changed_lines:
                        continue
                    if filename.endswith(('.md', '.mdx')) and is_in_code_context(text, match.start()):
                        continue
                    if incorrect in REQUIRED_CAPITALIZATIONS.keys():  
                        issue_message = f'verify whether "{matched_text}" should be written as "{correct}" to be interpreted as described in RFC 2119'
                    else:
                        issue_message = f'check whether "{matched_text}" should be written as "{correct}"'
                    issues.append({
                        'file': filename,
                        'line': line_num,
                        'issue': issue_message,
                        'type': 'capitalization'
                    })
                    matched_spans.append((start, end))  # Mark this region as matched
            return issues

        def check_validation_rules(lines, filename, changed_lines):
            issues = []
            in_fenced_code = False
            for line_num, line in enumerate(lines, 1):
                if line_num not in changed_lines:
                    continue
                if filename.endswith(('.md', '.mdx')):
                    if line.strip().startswith('```'):
                        in_fenced_code = not in_fenced_code
                        continue
                    if re.match(r'^\s{4,}', line):
                        continue
                    if in_fenced_code:
                        continue
                for rule in VALIDATION_RULES:
                    pattern = re.compile(rule['pattern'])
                    if pattern.search(line):
                        if not filename.endswith(('.md', '.mdx')):
                            if rule['name'] in ['No multiple consecutive spaces'] and ('```' in line or line.strip().startswith('    ')):
                                continue
                        if filename.endswith(('.md', '.mdx')) and '`' in line:
                            match = pattern.search(line)
                            if match:
                                before_match = line[:match.start()]
                                backticks_before = before_match.count('`')
                                if backticks_before % 2 == 1:
                                    continue
                        issues.append({
                            'file': filename,
                            'line': line_num,
                            'issue': rule['message'],
                            'type': 'formatting'
                        })
            return issues

        def validate_file(filepath, all_lines=False):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    lines = f.read().splitlines()
            except UnicodeDecodeError:
                return []
            except Exception as e:
                return [{
                    'file': str(filepath),
                    'line': 0,
                    'issue': f'Error reading file: {e}',
                    'type': 'error'
                }]

            if all_lines:
                changed_lines = set(range(1, len(lines) + 1))
            else:
                changed_lines = get_pr_diff_lines(filepath)
                if changed_lines is None or not changed_lines:
                    return []
            issues = []
            issues.extend(check_capitalization(lines, str(filepath), changed_lines))
            issues.extend(check_validation_rules(lines, str(filepath), changed_lines))
            return issues

        def main():
            all_lines = False
            files = []
            for arg in sys.argv[1:]:
                if arg == "--full":
                    all_lines = True
                else:
                    files.append(arg)
            if not files:
                print("Usage: python validate_text.py <file1> <file2> ... [--full]")
                sys.exit(1)
            all_issues = []
            for filepath in files:
                if os.path.isfile(filepath):
                    issues = validate_file(filepath, all_lines=all_lines)
                    all_issues.extend(issues)
            if all_issues:
                print("### Text Validation Issues Found\n")
                files_with_issues = {}
                for issue in all_issues:
                    filename = issue['file']
                    if filename not in files_with_issues:
                        files_with_issues[filename] = []
                    files_with_issues[filename].append(issue)
                for filename, issues in files_with_issues.items():
                    print(f"in **{filename}**")
                    for issue in issues:
                        icon = "üî§" if issue['type'] == 'capitalization' else "üìù" if issue['type'] == 'formatting' else "‚ùå"
                        print(f"- Line {issue['line']}: {icon} {issue['issue']}")
                    print()
                print(f"Total issues found: {len(all_issues)}")
                sys.exit(1)
            else:
                print("‚úÖ All text validation checks passed!")
                sys.exit(0)

        if __name__ == "__main__":
            main()
        EOF

    - name: Run text validation
      if: steps.changed-files.outputs.any_changed == 'true'
      continue-on-error: true
      run: |
        # Run validation and save output to a file
        # python validate_text.py ${{ steps.changed-files.outputs.all_changed_files }} | tee text_validation_output.txt
        set -o pipefail  # Make pipe return exit code of first failing command
        if python validate_text.py ${{ steps.changed-files.outputs.all_changed_files }} | tee text_validation_output.txt; then
          echo "‚úÖ Text validation passed"
        else
          echo "‚ùå Text validation failed"
          exit 1
        fi

    - name: Comment on PR (if issues found)
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          let details = '';
          try {
            details = fs.readFileSync('text_validation_output.txt', 'utf8');
          } catch (e) {
            details = '_Validation output file not found_';
          }

          const comment = `## üìù Text Validation Results

          Some text formatting issues were found in your PR. Please review and fix the following:

          <details>
          <summary>Full validation output</summary>

          ${details}

          </details>

          ---
          *This comment was automatically generated by the Text Validation workflow.*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
  
    - name: Full Text Validation
      if: github.event_name == 'workflow_dispatch'
      run: |
        python validate_text.py documentation/CAMARA-API-Event-Subscription-and-Notification-Guide.md documentation/CAMARA-API-Design-Guide.md --full
