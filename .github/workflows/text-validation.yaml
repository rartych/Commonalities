# Text Validation Workflow
# Checks capitalization of keywords and other text formatting rules in PR files

name: Text Validation

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'documentation/CAMARA-API-Event-Subscription-and-Notification-Guide.md'
      - 'documentation/CAMARA-API-Design-Guide.md'

jobs:
  text-validation:
    runs-on: ubuntu-latest
    name: Validate Text Formatting
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get changed files
      id: changed-files
      uses: tj-actions/changed-files@v40
      with:
        files: |
          documentation/CAMARA-API-Event-Subscription-and-Notification-Guide.md
          documentation/CAMARA-API-Design-Guide.md

    - name: Setup Python
      if: steps.changed-files.outputs.any_changed == 'true'
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Create validation script
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        cat > validate_text.py << 'EOF'
        #!/usr/bin/env python3
        import os
        import re
        import sys
        import subprocess
        from pathlib import Path

        def get_pr_diff_lines(filepath):
            """Get the line numbers of added/modified lines in the PR for a specific file."""
            try:
                # Get the diff for this specific file
                result = subprocess.run([
                    'git', 'diff', 'origin/main...HEAD', '--unified=0', filepath
                ], capture_output=True, text=True, check=True)
                
                diff_output = result.stdout
                if not diff_output:
                    return set()  # No changes in this file
                
                changed_lines = set()
                
                # Parse diff output to find added/modified lines
                for line in diff_output.split('\n'):
                    # Look for hunk headers like @@ -1,4 +1,6 @@
                    if line.startswith('@@'):
                        # Extract the new file line numbers
                        match = re.search(r'\+(\d+)(?:,(\d+))?', line)
                        if match:
                            start_line = int(match.group(1))
                            line_count = int(match.group(2)) if match.group(2) else 1
                            
                            # Add all lines in this hunk
                            for line_num in range(start_line, start_line + line_count):
                                changed_lines.add(line_num)
                
                return changed_lines
                
            except subprocess.CalledProcessError:
                # If git diff fails, fall back to checking all lines
                print(f"Warning: Could not get diff for {filepath}, checking entire file")
                return None
            except Exception as e:
                print(f"Error getting diff for {filepath}: {e}")
                return None

        def get_pr_added_content(filepath):
            """Get only the added/modified content from the PR diff."""
            try:
                # Get the diff with context to see actual content
                result = subprocess.run([
                    'git', 'diff', 'origin/main...HEAD', filepath
                ], capture_output=True, text=True, check=True)
                
                diff_output = result.stdout
                if not diff_output:
                    return ""  # No changes
                
                added_lines = []
                
                # Parse diff to extract only added lines (starting with +)
                for line in diff_output.split('\n'):
                    # Skip diff headers
                    if line.startswith('+++') or line.startswith('---') or line.startswith('@@'):
                        continue
                    # Collect added lines (but not the + symbol)
                    if line.startswith('+') and not line.startswith('+++'):
                        added_lines.append(line[1:])  # Remove the + prefix
                
                return '\n'.join(added_lines)
                
            except subprocess.CalledProcessError:
                return None
            except Exception as e:
                print(f"Error getting added content for {filepath}: {e}")
                return None

        # Define keywords that should be capitalized (case-sensitive)
        REQUIRED_CAPITALIZATIONS = {
            'github': 'GitHub',
            'api': 'API',
            'apis': 'APIs',
            'json': 'JSON',
            'xml': 'XML',
            'html': 'HTML',
            'must': 'MUST',
            'sql': 'SQL',
            'rest': 'REST',
            'graphql': 'GraphQL',
            'oauth': 'OAuth',
            'jwt': 'JWT',
            'http': 'HTTP',
            'https': 'HTTPS',
            'url': 'URL',
            'urls': 'URLs',
            'ui': 'UI',
            'ux': 'UX',
            'cli': 'CLI',
            'sdk': 'SDK',
            'npm': 'npm',  # npm is intentionally lowercase
            'yarn': 'Yarn',
            'webpack': 'webpack',  # webpack is intentionally lowercase
            'docker': 'Docker',
            'kubernetes': 'Kubernetes',
            'redis': 'Redis',
            'mongodb': 'MongoDB',
            'postgresql': 'PostgreSQL',
            'mysql': 'MySQL',
            'aws': 'AWS',
            'gcp': 'GCP',
            'azure': 'Azure',
            'linux': 'Linux',
            'windows': 'Windows',
            'macos': 'macOS',
            'ios': 'iOS',
            'android': 'Android',
        }

        # Additional validation rules
        VALIDATION_RULES = [
            {
                'name': 'No trailing whitespace',
                'pattern': r'[ \t]+$',
                'message': 'Line has trailing whitespace'
            },
            {
                'name': 'No multiple consecutive spaces',
                'pattern': r'[^\s]  +[^\s]',
                'message': 'Multiple consecutive spaces found (should be single space)'
            },
            {
                'name': 'Proper ellipsis',
                'pattern': r'\.\.\.(?!\.)',
                'message': 'Use proper ellipsis (…) or ensure consistent dot spacing'
            },
            {
                'name': 'Smart quotes consistency',
                'pattern': r'[""''`]',
                'message': 'Consider using consistent quote style'
            }
        ]

        def remove_markdown_code_blocks(text):
            """Remove code blocks and inline code from markdown text."""
            # Remove fenced code blocks (```...```)
            text = re.sub(r'```[\s\S]*?```', '', text, flags=re.MULTILINE)
            
            # Remove indented code blocks (4+ spaces at start of line)
            text = re.sub(r'^\s{4,}.*', '', text, flags=re.MULTILINE)
            
            # Remove inline code (`...`)
            text = re.sub(r'`[^`]*`', '', text)
            
            # Remove HTML code tags
            text = re.sub(r'<code[^>]*>.*?</code>', '', text, flags=re.DOTALL)
            text = re.sub(r'<pre[^>]*>.*?</pre>', '', text, flags=re.DOTALL)
            
            return text

        def is_in_code_context(text, position):
            """Check if a position is within a code block or inline code."""
            # Check if we're inside fenced code blocks
            before_text = text[:position]
            
            # Count triple backticks before this position
            backtick_blocks = before_text.count('```')
            if backtick_blocks % 2 == 1:  # Odd number means we're inside a code block
                return True
            
            # Check if we're on an indented code line
            lines_before = before_text.split('\n')
            current_line = lines_before[-1] if lines_before else ''
            if re.match(r'^\s{4,}', current_line):
                return True
            
            # Check if we're inside inline code
            current_line_start = before_text.rfind('\n') + 1
            line_to_position = text[current_line_start:position]
            backticks_in_line = line_to_position.count('`')
            if backticks_in_line % 2 == 1:  # Odd number means we're inside inline code
                return True
            
            return False

        def check_capitalization(text, filename, changed_lines=None):
            """Check for proper capitalization of technical keywords."""
            issues = []
            
            # Check each required capitalization
            for incorrect, correct in REQUIRED_CAPITALIZATIONS.items():
                # Use word boundaries to avoid partial matches
                pattern = r'\b' + re.escape(incorrect) + r'\b'
                matches = re.finditer(pattern, text, re.IGNORECASE)
                
                for match in matches:
                    matched_text = match.group()
                    # Skip if it's already correctly capitalized
                    if matched_text == correct:
                        continue
                    
                    # For markdown files, check if we're in a code context
                    if filename.endswith(('.md', '.mdx')) and is_in_code_context(text, match.start()):
                        continue
                    
                    line_num = text[:match.start()].count('\n') + 1
                    
                    # If we have changed_lines info, only report issues on changed lines
                    if changed_lines is not None and line_num not in changed_lines:
                        continue
                    
                    issues.append({
                        'file': filename,
                        'line': line_num,
                        'issue': f'"{matched_text}" should be "{correct}"',
                        'type': 'capitalization'
                    })
            
            return issues

        def check_validation_rules(text, filename, changed_lines=None):
            """Check additional validation rules."""
            issues = []
            lines = text.split('\n')
            
            # Track if we're inside a code block for markdown files
            in_fenced_code = False
            
            for line_num, line in enumerate(lines, 1):
                # If we have changed_lines info, only check changed lines
                if changed_lines is not None and line_num not in changed_lines:
                    continue
                
                # For markdown files, track code block state
                if filename.endswith(('.md', '.mdx')):
                    if line.strip().startswith('```'):
                        in_fenced_code = not in_fenced_code
                        continue
                    
                    # Skip indented code blocks (4+ spaces)
                    if re.match(r'^\s{4,}', line):
                        continue
                    
                    # Skip if we're inside a fenced code block
                    if in_fenced_code:
                        continue
                
                # Apply validation rules
                for rule in VALIDATION_RULES:
                    pattern = re.compile(rule['pattern'])
                    
                    if pattern.search(line):
                        # Additional skip conditions for non-markdown files
                        if not filename.endswith(('.md', '.mdx')):
                            if rule['name'] in ['No multiple consecutive spaces'] and ('```' in line or line.strip().startswith('    ')):
                                continue
                        
                        # Skip inline code in markdown
                        if filename.endswith(('.md', '.mdx')) and '`' in line:
                            # Simple check: if the match is between backticks, skip it
                            match = pattern.search(line)
                            if match:
                                before_match = line[:match.start()]
                                backticks_before = before_match.count('`')
                                if backticks_before % 2 == 1:  # Inside inline code
                                    continue
                        
                        issues.append({
                            'file': filename,
                            'line': line_num,
                            'issue': rule['message'],
                            'type': 'formatting'
                        })
            
            return issues

        def validate_file(filepath):
            """Validate a single file."""
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
            except UnicodeDecodeError:
                # Skip binary files
                return []
            except Exception as e:
                return [{
                    'file': str(filepath),
                    'line': 0,
                    'issue': f'Error reading file: {e}',
                    'type': 'error'
                }]
            
            issues = []
            issues.extend(check_capitalization(content, str(filepath)))
            issues.extend(check_validation_rules(content, str(filepath)))
            
            return issues

        def main():
            if len(sys.argv) < 2:
                print("Usage: python validate_text.py <file1> <file2> ...")
                sys.exit(1)
            
            all_issues = []
            
            for filepath in sys.argv[1:]:
                if os.path.isfile(filepath):
                    issues = validate_file(filepath)
                    all_issues.extend(issues)
            
            if all_issues:
                print("## Text Validation Issues Found\n")
                
                # Group issues by file
                files_with_issues = {}
                for issue in all_issues:
                    filename = issue['file']
                    if filename not in files_with_issues:
                        files_with_issues[filename] = []
                    files_with_issues[filename].append(issue)
                
                # Print issues grouped by file
                for filename, issues in files_with_issues.items():
                    print(f"### {filename}")
                    for issue in issues:
                        icon = "🔤" if issue['type'] == 'capitalization' else "📝" if issue['type'] == 'formatting' else "❌"
                        print(f"- Line {issue['line']}: {icon} {issue['issue']}")
                    print()
                
                print(f"Total issues found: {len(all_issues)}")
                sys.exit(1)
            else:
                print("✅ All text validation checks passed!")
                sys.exit(0)

        if __name__ == "__main__":
            main()
        EOF

    - name: Run text validation
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        python validate_text.py ${{ steps.changed-files.outputs.all_changed_files }}

    - name: Comment on PR (if issues found)
      if: failure() && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Create a comment with validation results
          const comment = `## 📝 Text Validation Results
          
          Some text formatting issues were found in your PR. Please review and fix the following:
          
          **Common issues to check:**
          - Ensure technical terms are properly capitalized (e.g., "GitHub" not "github")
          - Remove trailing whitespace from lines  
          - Use single spaces between words
          - Check for consistent formatting
          
          Please run the validation locally or check the workflow logs for detailed information about specific issues.
          
          ---
          *This comment was automatically generated by the Text Validation workflow.*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

  # Optional: Auto-fix some common issues
  # The following auto-fix job is commented out to avoid duplication and accidental execution.
  # If you want to enable auto-fix later, simply uncomment the lines below.

  # auto-fix:
  #   runs-on: ubuntu-latest
  #   name: Auto-fix Text Issues
  #   if: github.event_name == 'pull_request'
  #   needs: text-validation
  #   # Only run if text-validation failed and this is enabled
  #   # Remove the 'if: false' line below to enable auto-fixing
  #   if: false
  #   
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  #     with:
  #       token: ${{ secrets.GITHUB_TOKEN }}
  #       fetch-depth: 0
  #
  #   - name: Get changed files
  #     id: changed-files
  #     uses: tj-actions/changed-files@v40
  #     with:
  #       files: |
  #         **/*.md
  #         **/*.txt
  #         **/*.rst
  #         **/*.mdx
  #         docs/**
  #         README*
  #
  #   - name: Auto-fix common issues
  #     if: steps.changed-files.outputs.any_changed == 'true'
  #     run: |
  #       # Create a simple auto-fix script
  #       cat > auto_fix.py << 'EOF'
  #       import re
  #       import sys
  #       
  #       # Simple fixes that are safe to automate
  #       SAFE_FIXES = {
  #           r'\bgithub\b': 'GitHub',
  #           r'\bjavascript\b': 'JavaScript',
  #           r'\btypescript\b': 'TypeScript',
  #           r'\bapi\b': 'API',
  #           r'\bapis\b': 'APIs',
  #           r'\bjson\b': 'JSON',
  #           r' +$': '',  # Remove trailing whitespace
  #       }
  #       
  #       for filepath in sys.argv[1:]:
  #           try:
  #               with open(filepath, 'r') as f:
  #                   content = f.read()
  #               
  #               original_content = content
  #               for pattern, replacement in SAFE_FIXES.items():
  #                   content = re.sub(pattern, replacement, content, flags=re.IGNORECASE if pattern != r' +$' else 0)
  #               
  #               if content != original_content:
  #                   with open(filepath, 'w') as f:
  #                       f.write(content)
  #                   print(f"Fixed issues in {filepath}")
  #           except Exception as e:
  #               print(f"Error processing {filepath}: {e}")
  #       EOF
  #       
  #       python auto_fix.py ${{ steps.changed-files.outputs.all_changed_files }}
  #
  #   - name: Commit auto-fixes
  #     run: |
  #       git config --local user.email "action@github.com"
  #       git config --local user.name "GitHub Action"
  #       git add .
  #       if ! git diff --cached --quiet; then
  #         git commit -m "Auto-fix text formatting issues"
  #         git push
  #       fi
