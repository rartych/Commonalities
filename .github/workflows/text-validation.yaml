# Text Validation Workflow
# Checks capitalization of keywords and other text formatting rules in PR files

name: Text Validation

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'documentation/**'

jobs:
  text-validation:
    runs-on: ubuntu-latest
    name: Validate Text Formatting
    permissions:
      contents: read
      pull-requests: write  # Required for commenting on PRs
      issues: write         # Required for issue/PR comments
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get changed files
      id: changed-files
      uses: tj-actions/changed-files@v40
      with:
        files: |
          documentation/CAMARA-API-Event-Subscription-and-Notification-Guide.md
          documentation/CAMARA-API-Design-Guide.md

    - name: Setup Python
      if: steps.changed-files.outputs.any_changed == 'true'
      uses: actions/setup-python@v6
      with:
        python-version: '3.x'

    - name: Create validation script
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        cat > validate_text.py << 'EOF'
        #!/usr/bin/env python3
        import os
        import re
        import sys
        import subprocess
        from pathlib import Path

        def get_pr_diff_lines(filepath):
            """Get the line numbers of added/modified lines in the PR for a specific file."""
            try:
                result = subprocess.run([
                    'git', 'diff', 'origin/main...HEAD', '--unified=0', filepath
                ], capture_output=True, text=True, check=True)
                diff_output = result.stdout
                if not diff_output:
                    return set()
                changed_lines = set()
                for line in diff_output.split('\n'):
                    if line.startswith('@@'):
                        match = re.search(r'\+(\d+)(?:,(\d+))?', line)
                        if match:
                            start_line = int(match.group(1))
                            line_count = int(match.group(2)) if match.group(2) else 1
                            for line_num in range(start_line, start_line + line_count):
                                changed_lines.add(line_num)
                return changed_lines
            except subprocess.CalledProcessError:
                print(f"Warning: Could not get diff for {filepath}, checking entire file")
                return None
            except Exception as e:
                print(f"Error getting diff for {filepath}: {e}")
                return None

        REQUIRED_CAPITALIZATIONS = {
            'github': 'GitHub',
            'api': 'API',
            'apis': 'APIs',
            'must': 'MUST',
            'must not': 'MUST NOT',
            'should': 'SHOULD',
            'should not': 'SHOULD NOT',
            'may': 'MAY',
            'required': 'REQUIRED',
            'recommended': 'RECOMMENDED',
            'not recommended': 'NOT RECOMMENDED',
            'optional': 'OPTIONAL',
            'shall': 'SHALL',
            'shall not': 'SHALL NOT'
            # ... add others as needed
        }

        VALIDATION_RULES = [
            {
                'name': 'No trailing whitespace',
                'pattern': r'[ \t]+$',
                'message': 'Line has trailing whitespace'
            },
            # ... add others as needed
        ]

        def is_in_code_context(text, position):
            before_text = text[:position]
            backtick_blocks = before_text.count('```')
            if backtick_blocks % 2 == 1:
                return True
            lines_before = before_text.split('\n')
            current_line = lines_before[-1] if lines_before else ''
            if re.match(r'^\s{4,}', current_line):
                return True
            current_line_start = before_text.rfind('\n') + 1
            line_to_position = text[current_line_start:position]
            backticks_in_line = line_to_position.count('`')
            if backticks_in_line % 2 == 1:
                return True
            return False

        def check_capitalization(lines, filename, changed_lines):
            issues = []
            text = '\n'.join(lines)
            for incorrect, correct in REQUIRED_CAPITALIZATIONS.items():
                pattern = r'\b' + re.escape(incorrect) + r'\b'
                matches = re.finditer(pattern, text, re.IGNORECASE)
                for match in matches:
                    matched_text = match.group()
                    if matched_text == correct:
                        continue
                    line_num = text[:match.start()].count('\n') + 1
                    if line_num not in changed_lines:
                        continue
                    if filename.endswith(('.md', '.mdx')) and is_in_code_context(text, match.start()):
                        continue
                    issues.append({
                        'file': filename,
                        'line': line_num,
                        'issue': f'"{matched_text}" probably should be "{correct}"',
                        'type': 'capitalization'
                    })
            return issues

        def check_validation_rules(lines, filename, changed_lines):
            issues = []
            in_fenced_code = False
            for line_num, line in enumerate(lines, 1):
                if line_num not in changed_lines:
                    continue
                if filename.endswith(('.md', '.mdx')):
                    if line.strip().startswith('```'):
                        in_fenced_code = not in_fenced_code
                        continue
                    if re.match(r'^\s{4,}', line):
                        continue
                    if in_fenced_code:
                        continue
                for rule in VALIDATION_RULES:
                    pattern = re.compile(rule['pattern'])
                    if pattern.search(line):
                        if not filename.endswith(('.md', '.mdx')):
                            if rule['name'] in ['No multiple consecutive spaces'] and ('```' in line or line.strip().startswith('    ')):
                                continue
                        if filename.endswith(('.md', '.mdx')) and '`' in line:
                            match = pattern.search(line)
                            if match:
                                before_match = line[:match.start()]
                                backticks_before = before_match.count('`')
                                if backticks_before % 2 == 1:
                                    continue
                        issues.append({
                            'file': filename,
                            'line': line_num,
                            'issue': rule['message'],
                            'type': 'formatting'
                        })
            return issues

        def validate_file(filepath):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    lines = f.read().splitlines()
            except UnicodeDecodeError:
                return []
            except Exception as e:
                return [{
                    'file': str(filepath),
                    'line': 0,
                    'issue': f'Error reading file: {e}',
                    'type': 'error'
                }]
            changed_lines = get_pr_diff_lines(filepath)
            if changed_lines is None or not changed_lines:
                return []
            issues = []
            issues.extend(check_capitalization(lines, str(filepath), changed_lines))
            issues.extend(check_validation_rules(lines, str(filepath), changed_lines))
            return issues

        def main():
            if len(sys.argv) < 2:
                print("Usage: python validate_text.py <file1> <file2> ...")
                sys.exit(1)
            all_issues = []
            for filepath in sys.argv[1:]:
                if os.path.isfile(filepath):
                    issues = validate_file(filepath)
                    all_issues.extend(issues)
            if all_issues:
                print("### Text Validation Issues Found\n")
                files_with_issues = {}
                for issue in all_issues:
                    filename = issue['file']
                    if filename not in files_with_issues:
                        files_with_issues[filename] = []
                    files_with_issues[filename].append(issue)
                for filename, issues in files_with_issues.items():
                    print(f"### {filename}")
                    for issue in issues:
                        icon = "üî§" if issue['type'] == 'capitalization' else "üìù" if issue['type'] == 'formatting' else "‚ùå"
                        print(f"- Line {issue['line']}: {icon} {issue['issue']}")
                    print()
                print(f"Total issues found: {len(all_issues)}")
                sys.exit(1)
            else:
                print("‚úÖ All text validation checks passed!")
                sys.exit(0)

        if __name__ == "__main__":
            main()
        EOF

    - name: Run text validation
      if: steps.changed-files.outputs.any_changed == 'true'
      continue-on-error: true
      run: |
        # Run validation and save output to a file
        # python validate_text.py ${{ steps.changed-files.outputs.all_changed_files }} | tee text_validation_output.txt
        set -o pipefail  # Make pipe return exit code of first failing command
        if python validate_text.py ${{ steps.changed-files.outputs.all_changed_files }} | tee text_validation_output.txt; then
          echo "‚úÖ Text validation passed"
        else
          echo "‚ùå Text validation failed"
          exit 1
        fi

    - name: Comment on PR (if issues found)
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          let details = '';
          try {
            details = fs.readFileSync('text_validation_output.txt', 'utf8');
          } catch (e) {
            details = '_Validation output file not found_';
          }

          const comment = `## üìù Text Validation Results

          Some text formatting issues were found in your PR. Please review and fix the following:

          <details>
          <summary>Full validation output</summary>

          ${details}

          </details>

          ---
          *This comment was automatically generated by the Text Validation workflow.*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
  
  # Optional: Auto-fix some common issues
  # The following auto-fix job is commented out to avoid duplication and accidental execution.
  # If you want to enable auto-fix later, simply uncomment the lines below.

  # auto-fix:
  #   runs-on: ubuntu-latest
  #   name: Auto-fix Text Issues
  #   if: github.event_name == 'pull_request'
  #   needs: text-validation
  #   # Only run if text-validation failed and this is enabled
  #   # Remove the 'if: false' line below to enable auto-fixing
  #   if: false
  #   
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  #     with:
  #       token: ${{ secrets.GITHUB_TOKEN }}
  #       fetch-depth: 0
  #
  #   - name: Get changed files
  #     id: changed-files
  #     uses: tj-actions/changed-files@v40
  #     with:
  #       files: |
  #         **/*.md
  #         **/*.txt
  #         **/*.rst
  #         **/*.mdx
  #         docs/**
  #         README*
  #
  #   - name: Auto-fix common issues
  #     if: steps.changed-files.outputs.any_changed == 'true'
  #     run: |
  #       # Create a simple auto-fix script
  #       cat > auto_fix.py << 'EOF'
  #       import re
  #       import sys
  #       
  #       # Simple fixes that are safe to automate
  #       SAFE_FIXES = {
  #           r'\bgithub\b': 'GitHub',
  #           r'\bjavascript\b': 'JavaScript',
  #           r'\btypescript\b': 'TypeScript',
  #           r'\bapi\b': 'API',
  #           r'\bapis\b': 'APIs',
  #           r'\bjson\b': 'JSON',
  #           r' +$': '',  # Remove trailing whitespace
  #       }
  #       
  #       for filepath in sys.argv[1:]:
  #           try:
  #               with open(filepath, 'r') as f:
  #                   content = f.read()
  #               
  #               original_content = content
  #               for pattern, replacement in SAFE_FIXES.items():
  #                   content = re.sub(pattern, replacement, content, flags=re.IGNORECASE if pattern != r' +$' else 0)
  #               
  #               if content != original_content:
  #                   with open(filepath, 'w') as f:
  #                       f.write(content)
  #                   print(f"Fixed issues in {filepath}")
  #           except Exception as e:
  #               print(f"Error processing {filepath}: {e}")
  #       EOF
  #       
  #       python auto_fix.py ${{ steps.changed-files.outputs.all_changed_files }}
  #
  #   - name: Commit auto-fixes
  #     run: |
  #       git config --local user.email "action@github.com"
  #       git config --local user.name "GitHub Action"
  #       git add .
  #       if ! git diff --cached --quiet; then
  #         git commit -m "Auto-fix text formatting issues"
  #         git push
  #       fi
